<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pansheng`s Blog</title>
  <subtitle>不积跬步，无以至千里！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangpansheng.github.io/"/>
  <updated>2018-01-31T08:02:58.494Z</updated>
  <id>https://wangpansheng.github.io/</id>
  
  <author>
    <name>Pansheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手动一步一步搭建ss</title>
    <link href="https://wangpansheng.github.io/2018/01/31/%E6%89%8B%E5%8A%A8%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%90%AD%E5%BB%BAss/"/>
    <id>https://wangpansheng.github.io/2018/01/31/手动一步一步搭建ss/</id>
    <published>2018-01-31T08:02:12.000Z</published>
    <updated>2018-01-31T08:02:58.494Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=0&id=611811413&auto=1&height=32"></iframe>

<h1 id="动手安装ss-教程"><a href="#动手安装ss-教程" class="headerlink" title="动手安装ss,教程"></a>动手安装ss,教程</h1><h2 id="安装具体步骤"><a href="#安装具体步骤" class="headerlink" title="安装具体步骤"></a>安装具体步骤</h2><p> 我用的是Ubuntu系统，安装步骤非常简单，一步一步执行下面的命令就好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get updata</div><div class="line">&lt;!-- 如果服务器没有安装git，需要执行这一步 --&gt;</div><div class="line">sudo apt-get install git</div><div class="line">sudo apt-get install python-pip</div><div class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</div></pre></td></tr></table></figure>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><h4 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssserver -c /etc/shadowsocks.json</div></pre></td></tr></table></figure>
<h4 id="后台使用"><a href="#后台使用" class="headerlink" title="后台使用"></a>后台使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssserver -c /etc/shadowsocks.json -d start</div><div class="line">ssserver -c /etc/shadowsocks.json -d stop</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=0&amp;id=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css变形</title>
    <link href="https://wangpansheng.github.io/2017/07/11/css%E5%8F%98%E5%BD%A2/"/>
    <id>https://wangpansheng.github.io/2017/07/11/css变形/</id>
    <published>2017-07-11T01:23:13.000Z</published>
    <updated>2017-07-11T01:47:02.260Z</updated>
    
    <content type="html"><![CDATA[<h1>css变形</h1>

<blockquote>
<p>  我们可以借助css3实现图片元素的倾斜、缩放、移动、以及翻转效果。</p>
</blockquote>
<h2 id="1-tranfrom属性语法"><a href="#1-tranfrom属性语法" class="headerlink" title="1.  tranfrom属性语法"></a>1.  tranfrom属性语法</h2><blockquote>
<p>  tranfrom属性让元素在一个坐标系统中变形，包含一系列变形函数，可以移动、旋转和缩放元素。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transfrom: none | &lt;transfrom-function&gt;</div></pre></td></tr></table></figure>
<ul>
<li>默认值为:none,表示不对元素进行变形;</li>
<li>也可以指定一个或者多个变形函数，以空格分开。如：rotate、scale、trasnslate;</li>
</ul>
<h2 id="2-变形函数介绍"><a href="#2-变形函数介绍" class="headerlink" title="2.  变形函数介绍"></a>2.  变形函数介绍</h2><blockquote>
<p>  所有的2D变形函数可以应用于3D变形规范中。</p>
</blockquote>
<pre><code>函数 | 功能描述
----|-------
translate() | 移动元素，可以根据X轴和Y轴坐标重新定位自己的位置，有tranlateX(),translateY()
scale() | 缩小或者方法元素，可以使元素尺寸发生变化，有scaleX()和scaleY()
rotate() | 旋转元素
skew() | 让元素倾斜，在此基础上有两个扩展函数，skewX()和skewY()
matrix()|定义矩阵变形，基于X轴和Y轴坐标重新定位元素位置
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;css变形&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;  我们可以借助css3实现图片元素的倾斜、缩放、移动、以及翻转效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-tranfrom属性语法&quot;&gt;&lt;a href=&quot;#1-tranfrom属性语法&quot; clas
    
    </summary>
    
    
      <category term="css3" scheme="https://wangpansheng.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>前后端渲染的对比</title>
    <link href="https://wangpansheng.github.io/2017/05/14/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>https://wangpansheng.github.io/2017/05/14/前后端渲染的对比/</id>
    <published>2017-05-14T11:01:13.000Z</published>
    <updated>2017-05-14T11:08:46.640Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>  服务端渲染是通过后端模板引擎编译成html,css,js,然后回传给前端来进行显示；而前端渲染则是将整个生成逻辑代码全部回传前端，再由客户端生成用户界面。</p>
</blockquote>
<h2 id="为什么会有服务端渲染与客户端渲染"><a href="#为什么会有服务端渲染与客户端渲染" class="headerlink" title="为什么会有服务端渲染与客户端渲染"></a>为什么会有服务端渲染与客户端渲染</h2><p>早期，我们每一个页面都是直接由html，css，js实现的，每一个页面彼此之间相当于是独立的，当我们的网站应用足够大的时候，每当我们需要修改网站的内容时，我们需要更改很多的代码，非常麻烦。</p>
<p>那么后来，我们聪明的程序员就想到了，使用代码生成代码，就是后端的模板引擎，人们开始广泛使用模板代替手写html，大大减少的前端的工作量。通过代码生成代码，其实就是编译，基于html等基础语言，做出了更高层次的抽象封装，增加了易用性。</p>
<p>后来h5,c3的崛起，再加上客户端硬件性能的提升，我们开始通过前端模板引擎，来在客户端渲染页面。</p>
<p>对待模板，angular，vue，react的态度都不一样。</p>
<p><strong>前后端真正解耦，前端专注于UI视图,后台专注于数据处理，通过设计好的api交互，这是未来的趋势。</strong></p>
<h2 id="从-后端渲染-到-前端渲染-，有什么变化"><a href="#从-后端渲染-到-前端渲染-，有什么变化" class="headerlink" title="从 后端渲染 到 前端渲染 ，有什么变化"></a>从 后端渲染 到 前端渲染 ，有什么变化</h2><ul>
<li>计算任务的变化</li>
</ul>
<blockquote>
<p>  原来由后端执行的渲染任务，现在放在了前端来做，降低了多用户同时访问时服务端的压力，然后端专注做后端的事情，由于客户端硬件的发展，前端处理起来没有什么问题。</p>
</blockquote>
<ul>
<li>放弃前端权限</li>
</ul>
<blockquote>
<p>  将整个页面逻辑，交给客户端以后，会出现劫持的情况，比如某些运营商劫持之后，投放广告。俗话说的好<strong>一切在前端谈安全都是耍流氓</strong>，后端不能轻信前端发来的数据，一切数据都需要过滤与验证，最好使用ssl，屏蔽XSS。</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>总之一句话，后端渲染针对seo比较友好，前端渲染，可以减轻服务端的压力，提升服务器的性能，而且可以实现前后端分离！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  服务端渲染是通过后端模板引擎编译成html,css,js,然后回传给前端来进行显示；而前端渲染则是将整个生成逻辑代码全部回传前端，再由客户端生成用户界面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么会有服务端渲染与客户端渲染&quot;&gt;
    
    </summary>
    
    
      <category term="服务端渲染" scheme="https://wangpansheng.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu常用软件部署</title>
    <link href="https://wangpansheng.github.io/2017/04/02/ubuntu%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%83%A8%E7%BD%B2/"/>
    <id>https://wangpansheng.github.io/2017/04/02/ubuntu常用软件部署/</id>
    <published>2017-04-02T09:46:19.000Z</published>
    <updated>2017-04-24T10:20:33.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu中快速安装nodejs"><a href="#ubuntu中快速安装nodejs" class="headerlink" title="ubuntu中快速安装nodejs"></a>ubuntu中快速安装nodejs</h1><h2 id="1-我们可以直接通过apt-get安装nodejs"><a href="#1-我们可以直接通过apt-get安装nodejs" class="headerlink" title="1.  我们可以直接通过apt-get安装nodejs"></a>1.  我们可以直接通过<code>apt-get</code>安装nodejs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update //需要先刷新本地索引包</div><div class="line">sudo apt-get install nodejs //然后安装nodejs包</div><div class="line">sudo apt-get install npm    //安装npm包管理器</div></pre></td></tr></table></figure>
<h2 id="2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本"><a href="#2-安装好的node版本较低，我们可以使用n模块升级node到你需要打版本" class="headerlink" title="2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本"></a>2. 安装好的node版本较低，我们可以使用n模块升级node到你需要打版本</h2><h4 id="1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下"><a href="#1-node有一个-n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下" class="headerlink" title="1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下"></a>1.  node有一个 n模块，专门用来管理nodejs版本的。不过目前并不支持windows系统。我们先安装下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g n</div></pre></td></tr></table></figure>
<h4 id="2-升级到制定版本，我们可以在n加上指定的版本号就可以"><a href="#2-升级到制定版本，我们可以在n加上指定的版本号就可以" class="headerlink" title="2.  升级到制定版本，我们可以在n加上指定的版本号就可以"></a>2.  升级到制定版本，我们可以在n加上指定的版本号就可以</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo n 6.10.2</div></pre></td></tr></table></figure>
<h4 id="3-还有一些常用打快捷方法"><a href="#3-还有一些常用打快捷方法" class="headerlink" title="3.  还有一些常用打快捷方法"></a>3.  还有一些常用打快捷方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo n latest   //安装最新打官方版本</div><div class="line">sudo n stanle   //安装最新打稳定版</div><div class="line">sudo n lts      //安装最新打lts官方版</div></pre></td></tr></table></figure>
<h4 id="4-删除版本"><a href="#4-删除版本" class="headerlink" title="4.  删除版本"></a>4.  删除版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo n rm 0.9.4</div><div class="line">sudo n -0.9.4</div></pre></td></tr></table></figure>
<ul>
<li>更多命令，我们可以使用<code>n --help</code>寻求帮助</li>
</ul>
<h1 id="ubuntu常用工具安装"><a href="#ubuntu常用工具安装" class="headerlink" title="ubuntu常用工具安装"></a>ubuntu常用工具安装</h1><h2 id="右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率"><a href="#右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率" class="headerlink" title="右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率"></a>右上角任务栏显示cpu内存使用百分比，还可以显示网络传输速率</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor   //这里选择按enter键</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install indicator-sysmonitor</div><div class="line">//启动</div><div class="line">indicator-sysmonitor &amp;</div><div class="line">//ctrl+c后台运行该程序</div></pre></td></tr></table></figure>
<ul>
<li>启动之后，最好让程序开机自启动，鼠标右键点击标题栏上图标，弹出菜单，把<code>run on startup</code>后边打勾打上，然后进去advanced选项卡，就可以自定义配置需要显示在任务栏的项目啦</li>
</ul>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div><div class="line">git config --global user.name &quot;name&quot;</div><div class="line">git config --global user.email &quot;your@email.com&quot;</div></pre></td></tr></table></figure>
<h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install build-essential</div></pre></td></tr></table></figure>
<h2 id="安装yarn包管理工具"><a href="#安装yarn包管理工具" class="headerlink" title="安装yarn包管理工具"></a>安装yarn包管理工具</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g yarn</div></pre></td></tr></table></figure>
<h2 id="安装cnpm镜像源"><a href="#安装cnpm镜像源" class="headerlink" title="安装cnpm镜像源"></a>安装cnpm镜像源</h2><blockquote>
<p>  下载包直接可以使用 <code>cnpm install name</code> 下载</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g cnpm</div></pre></td></tr></table></figure>
<h2 id="安装nrm，node下载数据源管理器"><a href="#安装nrm，node下载数据源管理器" class="headerlink" title="安装nrm，node下载数据源管理器"></a>安装nrm，node下载数据源管理器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g nrm</div><div class="line">nrm -v //查看安装版本验证是否安装成功</div></pre></td></tr></table></figure>
<h4 id="可以查看当前所有的下载数据源链接"><a href="#可以查看当前所有的下载数据源链接" class="headerlink" title="可以查看当前所有的下载数据源链接"></a>可以查看当前所有的下载数据源链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nrm ls</div></pre></td></tr></table></figure>
<h4 id="测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源"><a href="#测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源" class="headerlink" title="测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源"></a>测试所有打镜像源的响应速度，然后根据测试我们可以切换我们需要使用的下载源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nrm test</div><div class="line">nrm use [taobao]</div></pre></td></tr></table></figure>
<h1 id="github使用ssh"><a href="#github使用ssh" class="headerlink" title="github使用ssh"></a>github使用ssh</h1><blockquote>
<p>  我们使用git去github上传东西，一般都使用ssh免密方式，所以需要首先生成一枚ssh-key密钥，然后在home文件夹进入个人文件夹中，按ctrl+h，会显示所有隐藏文件，打开.ssh文件夹中的id_rsa.pub文件，把里边内容粘贴到github上就可以啦</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -b 4096 -C &quot;wangpansheng@qq.com&quot;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ubuntu中快速安装nodejs&quot;&gt;&lt;a href=&quot;#ubuntu中快速安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;ubuntu中快速安装nodejs&quot;&gt;&lt;/a&gt;ubuntu中快速安装nodejs&lt;/h1&gt;&lt;h2 id=&quot;1-我们可
    
    </summary>
    
    
      <category term="linux" scheme="https://wangpansheng.github.io/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://wangpansheng.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu常见问题处理</title>
    <link href="https://wangpansheng.github.io/2017/04/02/ubuntu%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://wangpansheng.github.io/2017/04/02/ubuntu常见问题/</id>
    <published>2017-04-02T09:46:19.000Z</published>
    <updated>2017-04-24T12:21:54.474Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=0&id=611811413&auto=1&height=32"></iframe>


<h2 id="常见问题处理"><a href="#常见问题处理" class="headerlink" title="常见问题处理"></a>常见问题处理</h2><h3 id="1-win10和ubuntu双系统时，硬盘无法加载问题"><a href="#1-win10和ubuntu双系统时，硬盘无法加载问题" class="headerlink" title="1.  win10和ubuntu双系统时，硬盘无法加载问题"></a>1.  win10和ubuntu双系统时，硬盘无法加载问题</h3><ul>
<li><p>需要依赖于ntfs-3g，如果没有需要先安装这个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install ntfs-3g</div></pre></td></tr></table></figure>
</li>
<li><p>然后只用ntfsfix修复，即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ntfsfix /绝对路径</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常用软件推荐"><a href="#常用软件推荐" class="headerlink" title="常用软件推荐"></a>常用软件推荐</h2><h3 id="1-图片处理-GIMP"><a href="#1-图片处理-GIMP" class="headerlink" title="1.   图片处理:GIMP"></a>1.   图片处理:GIMP</h3><ul>
<li>对于非专业性的图片处理，该款APP已经十分足够了，功能也挺丰富、强大的。</li>
</ul>
<h3 id="2-视频播放：VLC"><a href="#2-视频播放：VLC" class="headerlink" title="2.  视频播放：VLC"></a>2.  视频播放：VLC</h3><ul>
<li>能够播放rmvb、mp4、avi等多种格式的视频文件，支持快速播放等功能。</li>
<li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository ppa:videolan/stable-daily</div><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install vlc</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-启动栏：Docky"><a href="#3-启动栏：Docky" class="headerlink" title="3.  启动栏：Docky"></a>3.  启动栏：Docky</h3><ul>
<li>ndicator-sysmonitor 这是一款能够实时查看当前系统的CPU、内存、网络、IP等信息</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=0&amp;id=
    
    </summary>
    
    
      <category term="linux" scheme="https://wangpansheng.github.io/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://wangpansheng.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>centos-01</title>
    <link href="https://wangpansheng.github.io/2017/03/03/centos-01/"/>
    <id>https://wangpansheng.github.io/2017/03/03/centos-01/</id>
    <published>2017-03-03T07:44:10.000Z</published>
    <updated>2017-05-03T09:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//查看当前centos系统的版本</div><div class="line">cat /etc/redhat-release</div><div class="line">//查看系统内核版本是32位还是64位</div><div class="line">uname -r</div><div class="line">//安装cnpm</div><div class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure>
</code></pre><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><blockquote>
<p>  在企业生产中，一般不会直接使用root来操作，可以通过命令创建用户，并且进行切换，普通用户下，前边显示的是$符号，root下显示的是#</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">useradd username    //添加用户名</div><div class="line">passwd username     //给刚才添加的用户，设置密码，然后会提示输入密码，输入两次就可以了</div><div class="line">su - username       //可以切换到指定的用户</div><div class="line">su - root           //可以切换到root</div><div class="line">whoami              //可以查看当前用户是谁</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
    
    </summary>
    
    
      <category term="centos" scheme="https://wangpansheng.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS构建express框架开发简单应用</title>
    <link href="https://wangpansheng.github.io/2017/01/10/nodeJS%E6%9E%84%E5%BB%BAexpress%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>https://wangpansheng.github.io/2017/01/10/nodeJS构建express框架开发简单应用/</id>
    <published>2017-01-10T13:39:28.000Z</published>
    <updated>2017-04-24T09:31:25.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>  使用node express简单构建，配合MongoDB数据库，实现简单的增删改查操作</p>
</blockquote>
<h2 id="首先我们需要构建express本地框架结构"><a href="#首先我们需要构建express本地框架结构" class="headerlink" title="首先我们需要构建express本地框架结构"></a>首先我们需要构建express本地框架结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">express demo</div><div class="line">//在demo文件夹中构建express结构</div></pre></td></tr></table></figure>
<h2 id="然后我们运行一下，"><a href="#然后我们运行一下，" class="headerlink" title="然后我们运行一下，"></a>然后我们运行一下，</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm start</div></pre></td></tr></table></figure>
<p>执行之后，我们在浏览器打开localhost:3000就可以看到初始化的页面，</p>
<h2 id="因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，"><a href="#因为我们是使用-MongoDb数据库，所以需要安装mongodb的nodeJS包，" class="headerlink" title="因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，"></a>因为我们是使用 MongoDb数据库，所以需要安装mongodb的nodeJS包，</h2><p>mongodb包的api基本上mongodb数据库的命令行操作命令差不多，所以，如果你比较清楚命令行操作命令，使用起来就会非常方便，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//安装mongodb包</div><div class="line">npm install mongodb --save</div><div class="line">//安装依赖包</div><div class="line">npm install</div></pre></td></tr></table></figure></p>
<p>至此，所有的准备工作基本完成，当然，前提你已经装好mongodb数据库，而且在使用的时候，需要全程开启数据库服务器。mongodb数据库的安装，我以前有文章有介绍过，有兴趣的可以去看看。</p>
<h2 id="我们使用MVC架构来实现针对数据库的增删改查，"><a href="#我们使用MVC架构来实现针对数据库的增删改查，" class="headerlink" title="我们使用MVC架构来实现针对数据库的增删改查，"></a>我们使用MVC架构来实现针对数据库的增删改查，</h2><ul>
<li>我们创建一个文件夹 module，就是连接控制数据库的文件。</li>
<li>我们使用routes来代替controller同样的功能，来连接视图层和数据库的连接。</li>
<li>我们的整体逻辑是，我们路由中添加一个get请求，请求中调用module中的一个操作方法，然后module中的添加方法，再去调用数据库连接，然后在使用操作api操作数据库。<h2 id="在module中首先连接到数据库"><a href="#在module中首先连接到数据库" class="headerlink" title="在module中首先连接到数据库"></a>在module中首先连接到数据库</h2></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//得到MongoClient对象</span></div><div class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">"mongodb"</span>).MongoClient;</div><div class="line"><span class="keyword">var</span> url = <span class="string">"数据库主机ip:port/数据库名"</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line"></div><div class="line">    MongoClient.connect(url,<span class="function"><span class="keyword">function</span>(<span class="params">err,db</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(err)&#123;</div><div class="line">            <span class="comment">//代表连接失败</span></div><div class="line">        <span class="keyword">return</span> callback(err);</div><div class="line">        &#125;</div><div class="line">        callback(<span class="literal">null</span>,db)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  使用node express简单构建，配合MongoDB数据库，实现简单的增删改查操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;首先我们需要构建express本地框架结构&quot;&gt;&lt;a href=&quot;#首先我们需要构建express本地框架
    
    </summary>
    
    
      <category term="NodeJS express" scheme="https://wangpansheng.github.io/tags/NodeJS-express/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB数据库配合NodeJS简单使用</title>
    <link href="https://wangpansheng.github.io/2017/01/09/MongoDB%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wangpansheng.github.io/2017/01/09/MongoDB简单学习/</id>
    <published>2017-01-09T11:11:15.000Z</published>
    <updated>2017-04-24T10:16:06.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-MongoDB"><a href="#关于-MongoDB" class="headerlink" title="关于 MongoDB"></a>关于 MongoDB</h2><blockquote>
<p>  我们一般把数据库分为关系型数据库和非关系型数据库，MongoDB就是属于非关系型数据库的一种。</p>
</blockquote>
<ul>
<li>官网：<a href="https://www.mongodb.com/" target="_blank" rel="external">https://www.mongodb.com/</a></li>
<li>下载地址：<a href="https://www.mongodb.com/download-center?jmp=nav" target="_blank" rel="external">https://www.mongodb.com/download-center?jmp=nav</a></li>
</ul>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><ul>
<li><a href="https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN" target="_blank" rel="external">https://www.smartftp.com/support/kb/the-program-cant-start-because-api-ms-win-crt-runtime-l1-1-0dll-is-missing-f2702.html?lang=zh-CN</a></li>
<li><a href="http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file" target="_blank" rel="external">http://stackoverflow.com/questions/33265663/api-ms-win-crt-runtime-l1-1-0-dll-is-missing-when-opening-microsoft-office-file</a></li>
</ul>
<h2 id="启动和关闭-MongoDB-数据库服务程序"><a href="#启动和关闭-MongoDB-数据库服务程序" class="headerlink" title="启动和关闭 MongoDB 数据库服务程序"></a>启动和关闭 MongoDB 数据库服务程序</h2><p>mongod.exe 是我们要启动的服务器文件<br>mongo的客户端去连我们的服务器</p>
<ul>
<li><p>打开终端，输入 <code>mongod</code> 回车</p>
<ul>
<li><code>mongod</code> 命令用来启动 MongoDB 数据服务</li>
<li>MongoDB 服务默认将 C:/data/db 目录作为数据目录</li>
<li>所以你需要先在 C:/ 根目录新建一个目录：C:/data/db</li>
<li>当你执行 mongod 命令的时候，默认会去使用 c:/data/db 目录作为数据存储目录</li>
<li>如果你不想使用 c:/data/db 目录</li>
<li>mongod –dbpath=路径</li>
</ul>
</li>
<li><p>32位操作系统启动 MongoDB</p>
<ul>
<li><a href="http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html" target="_blank" rel="external">http://jingyan.baidu.com/article/76a7e409e1bb49fc3b6e1516.html</a></li>
<li><code>mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1</code><br>mongod –dbpath C:/data/db –journal –storageEngine=mmapv1`</li>
</ul>
</li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ol>
<li>什么是数据？</li>
</ol>
<blockquote>
<p>数据是信息的表现形式和载体，可以是符号、文字、数字、语音、图像、视频等。通俗一点，数据就是信息，例如，个人信息、账户信息、家庭信息、企业信息、财务信息等等。</p>
</blockquote>
<ol>
<li>什么是数据库（Database，DB）？</li>
</ol>
<blockquote>
<p> 数据库是按照数据结构来组织、存储和管理数据的仓库。</p>
</blockquote>
<ol>
<li>为什么要使用数据库？</li>
</ol>
<blockquote>
<p>   我们需要使用数据库来存储我们网站的数据，然后通过增删改查进行数据交互，数据库，为我们提供了存储数据的仓库。</p>
</blockquote>
<ol>
<li>什么是数据库管理系统（DataBase Management System，DBMS）？</li>
</ol>
<blockquote>
<p> 数据库管理系统（DataBase Management System，DBMS）是为管理数据库而设计的大型电脑软件管理系统.例如，Oracle、Microsoft SQL Server、Access、MySQL、PostgreSQL、db2等等.我们可以简称这些数据库管理系统为数据库，虽然这种叫法不是很严谨，但是一般人都听的懂。</p>
</blockquote>
<ol>
<li>数据库的分类</li>
</ol>
<ul>
<li>关系型数据库 sql语言</li>
</ul>
<blockquote>
<p>关系数据库管理系统(Relational Database Management System)，<br>是将数据组织为相关的行和列的系统，而管理关系数据库的计算机软件就是关系数据库管理系统，常用的数据库软件有Oracle、SQL Server、MySQL等。</p>
</blockquote>
<ul>
<li>非关系型数据库 nosql<ul>
<li>内存数据库 redis</li>
<li>面向文档数据库 mongodb</li>
</ul>
</li>
</ul>
<h2 id="文档-document"><a href="#文档-document" class="headerlink" title="文档 document"></a>文档 document</h2><blockquote>
<p>文档是MongoDB中最基本的单元，里边包含多个键值对。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;name:"zhangsan",age:12&#125;</div><div class="line">&#123;name:"lisi"&#125;</div></pre></td></tr></table></figure>
<h2 id="集合-collection"><a href="#集合-collection" class="headerlink" title="集合 collection"></a>集合 collection</h2><blockquote>
<p>集合就是一组文档，特点是动态模式，集合中每一个文档都有可能不一样。但是在实际开发中，最好我们保存一样格式的文档。</p>
</blockquote>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h4 id="1-列出所有的数据库"><a href="#1-列出所有的数据库" class="headerlink" title="1.  列出所有的数据库"></a>1.  列出所有的数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show dbs</div></pre></td></tr></table></figure>
<h4 id="2-进入或者新建数据库user"><a href="#2-进入或者新建数据库user" class="headerlink" title="2.  进入或者新建数据库user"></a>2.  进入或者新建数据库user</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">use user</div><div class="line">//如果已经有了user数据库，就会进入user数据库</div><div class="line">//如果没有user数据库，就会自动新建数据库，如果数据库中没有任何文档，则用show dbs不会显示该仓库</div></pre></td></tr></table></figure>
<h4 id="3-新建文档"><a href="#3-新建文档" class="headerlink" title="3.  新建文档"></a>3.  新建文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.user.insert(&#123;name:<span class="string">"wang"</span>&#125;)</div><div class="line">//在user集合中添加一条文档数据</div></pre></td></tr></table></figure>
<h4 id="4-查看user集合中的文档"><a href="#4-查看user集合中的文档" class="headerlink" title="4.  查看user集合中的文档"></a>4.  查看user集合中的文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.find()</div></pre></td></tr></table></figure>
<h4 id="5-更新文档内容"><a href="#5-更新文档内容" class="headerlink" title="5.  更新文档内容"></a>5.  更新文档内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.update(&#123;name:<span class="string">"wang"</span>&#125;,&#123;<span class="variable">$set</span>:&#123;name:<span class="string">"ang"</span>&#125;&#125;)</div></pre></td></tr></table></figure>
<h4 id="6-删除文档"><a href="#6-删除文档" class="headerlink" title="6.  删除文档"></a>6.  删除文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.user.remove(&#123;name:<span class="string">"wang"</span>&#125;)</div><div class="line">//如果不传入参数，则会直接删除集合</div></pre></td></tr></table></figure>
<h3 id="7-删除数据库"><a href="#7-删除数据库" class="headerlink" title="7.  删除数据库"></a>7.  删除数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use user</div><div class="line">db.dropDatabase()</div></pre></td></tr></table></figure>
<h2 id="js链接MongoDb"><a href="#js链接MongoDb" class="headerlink" title="js链接MongoDb"></a>js链接MongoDb</h2><blockquote>
<p> mongodb包提供的方法api和monggodb的命令基本一样，我们可以在nodejs中使用mongodb数据库进行增删改查操作。</p>
</blockquote>
<ul>
<li>api地址：<a href="http://mongodb.github.io/node-mongodb-native/2.2/api" target="_blank" rel="external">http://mongodb.github.io/node-mongodb-native/2.2/api</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于-MongoDB&quot;&gt;&lt;a href=&quot;#关于-MongoDB&quot; class=&quot;headerlink&quot; title=&quot;关于 MongoDB&quot;&gt;&lt;/a&gt;关于 MongoDB&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  我们一般把数据库分为关系型数据库和非关系型数据
    
    </summary>
    
    
      <category term="MongoDB" scheme="https://wangpansheng.github.io/tags/MongoDB/"/>
    
      <category term="NodeJS" scheme="https://wangpansheng.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>数组方法梳理</title>
    <link href="https://wangpansheng.github.io/2016/11/26/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/"/>
    <id>https://wangpansheng.github.io/2016/11/26/数组方法梳理/</id>
    <published>2016-11-26T00:55:03.000Z</published>
    <updated>2017-04-24T09:37:33.493Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=0&id=611811413&auto=1&height=32"></iframe>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/bg2.jpg" alt="images/bg2.jpg" title="">
                </div>
                <div class="image-caption">images/bg2.jpg</div>
            </figure>
<blockquote>
<p>  由于发现对数组和字符串原生的方法有点记不太清了，所以打算梳理一下，把这写方法整理一下，加强自己的记忆。</p>
<p>  以下数组演示都以数组 数组arr=[1,2,3]为原始值；</p>
</blockquote>
<h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><ul>
<li><p>返回数组的长度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.length;<span class="comment">//返回值是3</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul>
<li><p>连接两个或更多数组，并返回新数组，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr.concat([<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]);</div><div class="line"><span class="comment">//返回是数组[1,2,3,8,9,0]</span></div><div class="line"><span class="comment">//不会修改原数组</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul>
<li><p>把数组的所有元素放进一个新的字符串，元素根据指定的字符串分割</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.join(<span class="string">""</span>);</div><div class="line"><span class="comment">//返回值是字符串123</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><ul>
<li><p>删除并返回最后一个元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr.pop();</div><div class="line"><span class="comment">//从数组中删除最后一个元素</span></div><div class="line"><span class="comment">//返回值是删除的元素，</span></div><div class="line"><span class="comment">//原数组被更改</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><ul>
<li>向数组最后添加一个或多个元素，并返回添加之后数组的长度<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">arr.push(<span class="number">3</span>);</div><div class="line"><span class="comment">//返回值是新数组长度</span></div><div class="line"><span class="comment">//原数组被更改</span></div><div class="line">arr.push([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="comment">//这样调用，会把传入的数组当作数组一个元素</span></div><div class="line">arr.push(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</div><div class="line"><span class="comment">//会把传入的值按照先后顺序放在数组的最后</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><ul>
<li><p>颠倒数组中元素的排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.reverse();</div><div class="line"><span class="comment">//返回值和原数组都是反转之后的数组</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><ul>
<li><p>删除并返回数组的第一个元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr.shift();</div><div class="line"><span class="comment">//返回被删除的元素</span></div><div class="line"><span class="comment">//会修改原数组</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><ul>
<li>在数组最前添加一个或多个元素，返回新长度<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr.unshift([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</div><div class="line">arr.unshift(<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>);</div><div class="line"><span class="comment">//如果传入多个元素，传入的第一个元素会在数组的索引0上，第二个会在1上，以此类推，</span></div><div class="line"><span class="comment">//简单理解，传入多个元素，直接把传入的内容直接放在最前边；</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ul>
<li><p>选取并返回数组中指定的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr.slice(start,end);</div><div class="line"><span class="comment">//strat是开始索引值，end是结束索引值，不包含end索引的值</span></div><div class="line"><span class="comment">//如果索引值是负数，-1就是最后一个元素，以此类推</span></div><div class="line"><span class="comment">//如果没有第二个值，那么从start开始截取到数组结束</span></div><div class="line"><span class="comment">//不会修改原元素</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><ul>
<li><p>对数组的元素进行排序,直接对原数组进行排序，返回值也是排序后的新数组,如果不传参数，则是按照元素首字母排序，如果需要按照指定的规则排序，需要传入指定的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.sort();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ul>
<li><p>从数组中添加删除元素，返回被删除的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr.splice(index,howmany,item1...itemx); </div><div class="line"><span class="comment">//index 添加或删除元素的索引位置</span></div><div class="line"><span class="comment">//howmany 要删除元素的个数，不删除可以设置为0</span></div><div class="line"><span class="comment">//item 要添加的元素</span></div><div class="line"><span class="comment">//返回值是删除的元素</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="toSource"><a href="#toSource" class="headerlink" title="toSource()"></a>toSource()</h3><ul>
<li>返回对象的源代码,只有火狐支持</li>
</ul>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ul>
<li>把数组转换为字符串，并返回结果</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=0&amp;id=
    
    </summary>
    
    
      <category term="数组，js基础" scheme="https://wangpansheng.github.io/tags/%E6%95%B0%E7%BB%84%EF%BC%8Cjs%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>原生框架封装之插件开发</title>
    <link href="https://wangpansheng.github.io/2016/11/20/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E4%B9%8B%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://wangpansheng.github.io/2016/11/20/原生框架封装之插件开发/</id>
    <published>2016-11-20T01:25:49.000Z</published>
    <updated>2017-04-24T09:39:15.180Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=0&id=611811413&auto=1&height=32"></iframe>


<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ol>
<li><p>历史背景</p>
<ul>
<li>http https: 都是一种无状态、无连接的协议</li>
<li>tcp/ip 是一种长连接协议</li>
<li>无论什么用户都可以访问网址页面，在实际开发中，有些页面需要先验证身份才可以访问的，此时就需要http记录用户的状态，（登录状态），</li>
<li>但是http协议是无状态的，因此就诞生了session和cookie</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>登录功能：记录登录状态，以及一些用户基本信息。</li>
<li>用户基本信息：昵称、头像地址、加密后的密码（记住密码）、用户名</li>
</ul>
</li>
<li><p>做cookie插件的目的</p>
</li>
</ol>
<ul>
<li>方便前端人员操作cookie</li>
</ul>
<h2 id="原生js操作cookie"><a href="#原生js操作cookie" class="headerlink" title="原生js操作cookie"></a>原生js操作cookie</h2><ol>
<li><p>获取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie</div></pre></td></tr></table></figure>
</li>
<li><p>操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie = <span class="string">"username=guoguo"</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>设置有效期</p>
<ul>
<li><p>默认如果没有设置cookie有效期，它就是一个会话的cookie，也就是说，当浏览器关闭时，该cookie的信息会被清除掉</p>
</li>
<li><p>在设置cookie有效期时，单位是天，在原生设置cookie有效期时，要给expiries赋值为截止日期；</p>
</li>
</ul>
</li>
<li><p>设置域名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">domain=<span class="string">"xxx.com"</span></div></pre></td></tr></table></figure>
</li>
<li><p>设置路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path=<span class="string">"/"</span></div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=0&amp;id=
    
    </summary>
    
    
      <category term="原生框架封装" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85/"/>
    
      <category term="js，jquery" scheme="https://wangpansheng.github.io/tags/js%EF%BC%8Cjquery/"/>
    
  </entry>
  
  <entry>
    <title>jqeury框架封装练习3</title>
    <link href="https://wangpansheng.github.io/2016/11/18/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A03/"/>
    <id>https://wangpansheng.github.io/2016/11/18/框架封装练习3/</id>
    <published>2016-11-18T03:23:09.000Z</published>
    <updated>2017-04-24T09:36:45.223Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=0&id=611811413&auto=1&height=32"></iframe>

<h2 id="DOM操作模块"><a href="#DOM操作模块" class="headerlink" title="DOM操作模块"></a>DOM操作模块</h2><h3 id="appendTO方法"><a href="#appendTO方法" class="headerlink" title="appendTO方法"></a>appendTO方法</h3><ol>
<li><p>语法：实例对象.appendTo(target);</p>
</li>
<li><p>功能：将调用者上的所有DOM元素，分别追加到目标元素上</p>
</li>
<li><p>target参数类型：</p>
<ul>
<li>选择器</li>
<li>DOM元素</li>
<li>DOM数组，伪数组</li>
</ul>
</li>
</ol>
<ul>
<li><p>为了更方便处理不同的类型，在实现时，首先统一target的参数类型，方便发i吗逻辑的处理</p>
</li>
<li><p>将target统一成itcast的对象，参数一致，便于处理，同时由于是itcast对象，就可以直接调用each方法进行遍历元素</p>
</li>
</ul>
<ol>
<li>实现思路</li>
</ol>
<ul>
<li>统一target类型，</li>
<li>遍历target，再遍历调用者</li>
<li>判断，当目标元素是不是第一个元素，如果是，不需要拷贝源节点，否则就要深拷贝源节点，</li>
<li>将上述得到的新节点，缓存起来到数组中，</li>
<li>再将新节点追加到dom元素中</li>
<li>将缓存的数组转换成itcast对象，作为appendTo的返回值，来实现链式编程。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><ol>
<li><p>功能：    将传入参数追加给调用者。</p>
</li>
<li><p>思路：</p>
<ul>
<li>将传入实参转换成itcast对象</li>
<li>用传入的实参调用appendTo方法，将this作为目标元素传入appendTo方法</li>
<li>实现链式编程</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=0&amp;id=
    
    </summary>
    
    
      <category term="原生框架" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JavaScript" scheme="https://wangpansheng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>框架封装之Ajax</title>
    <link href="https://wangpansheng.github.io/2016/11/17/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E4%B9%8BAjax/"/>
    <id>https://wangpansheng.github.io/2016/11/17/框架封装之Ajax/</id>
    <published>2016-11-17T01:31:26.000Z</published>
    <updated>2017-04-24T09:37:10.100Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=0&id=611811413&auto=1&height=32"></iframe>

<h2 id="ajax请求步骤"><a href="#ajax请求步骤" class="headerlink" title="ajax请求步骤"></a>ajax请求步骤</h2><ol>
<li>创建请求对象</li>
<li>格式化数据</li>
<li>与服务器建立连接</li>
<li>监听请求状态</li>
<li>发送请求</li>
</ol>
<h2 id="创建请求对象"><a href="#创建请求对象" class="headerlink" title="创建请求对象"></a>创建请求对象</h2><ol>
<li><p>原生方法</p>
<ul>
<li>w3c:XMLHttpRequest</li>
<li>IE：ActiveXObject</li>
</ul>
</li>
<li><p>兼容处理</p>
</li>
</ol>
<h2 id="封装Ajax模块"><a href="#封装Ajax模块" class="headerlink" title="封装Ajax模块"></a>封装Ajax模块</h2><ol>
<li><p>确定Ajax配置的默认值</p>
<ul>
<li>url =&gt; “”</li>
<li>type =&gt; “get”</li>
<li>data =&gt; {}</li>
<li>success =&gt; null</li>
<li>fail =&gt; null</li>
<li>async =&gt; true</li>
<li>dataType =&gt; “json”</li>
<li>contentType =&gt; “application/x-www-form-ulencoded”</li>
</ul>
</li>
<li><p>ajax默认配置放在哪？</p>
<ul>
<li>要用一个对象来存储上述Ajax配置信息，像jQuery一样，将其放到工厂函数上；<br>放在工厂函数jq上</li>
</ul>
</li>
</ol>
<h3 id="改造extend方法"><a href="#改造extend方法" class="headerlink" title="改造extend方法"></a>改造extend方法</h3><ol>
<li>如果只传入一个参数，给this扩展成员，</li>
<li>或者传入两个以上，就是给第一个参数扩展成员，，</li>
</ol>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ol>
<li><p>jsonp跨域的一种方式，缺点：只能发送跨域get请求</p>
</li>
<li><p>本质：利用script标签的src属性可以跨域的特性</p>
</li>
<li><p>实现流程：</p>
<ul>
<li>创建script标签，添加到head下</li>
<li>常见一个全局函数，用来处理服务器响应的数据</li>
<li>指定script标签src的属性值，同时将全局函数发送到服务区</li>
<li>要与后台人员沟通，将发送全局函数的参数名告诉后台人员</li>
<li></li>
</ul>
</li>
<li>实现步骤：<ul>
<li>常见请求对象，script标签</li>
<li>格式化数据</li>
<li>创建一个全局函数，将函数添加到data内，</li>
<li>监听请求的状态-》使用timeout来做请求状态的监听，如果在超过时间内，表示成功，否则就报超时，</li>
<li>发送请求，-》给script标签指定src属性值</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=0&amp;id=
    
    </summary>
    
    
      <category term="框架封装，ajax" scheme="https://wangpansheng.github.io/tags/%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%EF%BC%8Cajax/"/>
    
  </entry>
  
  <entry>
    <title>原生框架封装练习02</title>
    <link href="https://wangpansheng.github.io/2016/11/17/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A02/"/>
    <id>https://wangpansheng.github.io/2016/11/17/原生框架封装练习2/</id>
    <published>2016-11-17T01:26:35.000Z</published>
    <updated>2017-04-24T09:38:28.076Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=0&id=611811413&auto=1&height=32"></iframe>

<h2 id="工具类方法与功能类方法"><a href="#工具类方法与功能类方法" class="headerlink" title="工具类方法与功能类方法"></a>工具类方法与功能类方法</h2><ol>
<li><p>工具类方法：</p>
<ul>
<li>可以在内部使用，也可以给使用者使用，不需要常见实例就可以调用的</li>
</ul>
</li>
<li><p>功能类方法：</p>
<ul>
<li>框架内部的对象的方法，必须使用该对象去调用，操作dom元素的方法</li>
</ul>
</li>
</ol>
<h2 id="类型判断方法"><a href="#类型判断方法" class="headerlink" title="类型判断方法"></a>类型判断方法</h2><ol>
<li><p>isString方法：判断指定 参数是不是字符串类型，</p>
</li>
<li><p>isHTML：判断指定参数是不是html字符串</p>
<ul>
<li>以&lt;开头，以&gt;结尾，长度不小于3的字符串</li>
</ul>
</li>
<li><p>isDOM：判断指定的参数是不是dom对象</p>
<ul>
<li>如果参数不为null或undefined，并且具有nodetype属性，那么类型就是dom对象</li>
</ul>
</li>
<li><p>isArrayLink：判断指定参数是不是数组或伪数组</p>
<ul>
<li>如果对象的length属性是number类型</li>
</ul>
</li>
<li><p>isFunction：</p>
<ul>
<li></li>
</ul>
</li>
<li><p>iswindow：判断指定参数是不是window</p>
<ul>
<li>如果参数值不是null undefined，并具有window属性指向自己，那么该对象就是window</li>
</ul>
</li>
</ol>
<h2 id="工具类方法"><a href="#工具类方法" class="headerlink" title="工具类方法"></a>工具类方法</h2><ol>
<li><p>type方法：</p>
</li>
<li><p>ParseHTML方法：将html字符串转换为对应的元素节点</p>
</li>
</ol>
<h2 id="selector参数类型与逻辑"><a href="#selector参数类型与逻辑" class="headerlink" title="selector参数类型与逻辑"></a>selector参数类型与逻辑</h2><h2 id="保持itcast对象是伪数组"><a href="#保持itcast对象是伪数组" class="headerlink" title="保持itcast对象是伪数组"></a>保持itcast对象是伪数组</h2><ul>
<li>在itcast的原型上添加length=0；表示itcast对象默认的属相为0；</li>
</ul>
<h2 id="功能类方法toArray"><a href="#功能类方法toArray" class="headerlink" title="功能类方法toArray"></a>功能类方法toArray</h2><ol>
<li></li>
<li><p>功能：将itcast对象，转换成真数组</p>
</li>
<li><p>实现思路：借调数组的slice方法，</p>
</li>
</ol>
<h2 id="功能类get方法"><a href="#功能类get方法" class="headerlink" title="功能类get方法"></a>功能类get方法</h2><ol>
<li><p>语法：<code>itcast对象.get( index )</code></p>
</li>
<li><p>功能：根据索引获取指定的dom元素</p>
</li>
<li><p>实现思路：</p>
<ul>
<li>判断index是不是null undefined值，如果是就返回一个数组，存储itcast对象所有的dom元素</li>
<li>判断index是否小于0，是 就index+this.length转换成自然数索引值，</li>
<li>返回this[index]</li>
</ul>
</li>
</ol>
<h2 id="鸭子类型Ducking-Type"><a href="#鸭子类型Ducking-Type" class="headerlink" title="鸭子类型Ducking Type"></a>鸭子类型Ducking Type</h2><ul>
<li><p>如果一个东西，走路像鸭子，声音像鸭子，那么它就是鸭子。</p>
</li>
<li><p>实现伪数组对象，在控制台显示时是以数组形式显示</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=0&amp;id=
    
    </summary>
    
    
      <category term="原生框架封装" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85/"/>
    
      <category term="原生js实现jq" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0jq/"/>
    
  </entry>
  
  <entry>
    <title>jquery框架封装练习01</title>
    <link href="https://wangpansheng.github.io/2016/11/15/%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%E7%BB%83%E4%B9%A001/"/>
    <id>https://wangpansheng.github.io/2016/11/15/原生框架封装练习01/</id>
    <published>2016-11-15T07:07:04.000Z</published>
    <updated>2017-04-24T09:38:10.282Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>我们通过原生的js实现一些jq的功能，通过练习，锻炼我们的分析问题的能力。锻炼编程的思维能力。</p>
</li>
<li><p>查询DOM方法</p>
</li>
<li>操作DOM方法<ul>
<li>appendTo</li>
<li>append</li>
<li>prependTo</li>
<li>prepend</li>
<li>next/prev</li>
<li>nextAll/prevAll</li>
<li>before</li>
<li>after</li>
<li>parent /parents</li>
<li>nextSibling</li>
<li>attr</li>
<li>prop</li>
<li>val</li>
<li>html</li>
<li>text</li>
<li>css</li>
<li>addClass</li>
<li>hasClass</li>
<li>removeClass</li>
<li>toggleClass</li>
<li>on</li>
<li>off</li>
<li>click /dbclick/keydown</li>
<li>$.ajax</li>
</ul>
</li>
</ul>
<h2 id="jQuery框架结构"><a href="#jQuery框架结构" class="headerlink" title="jQuery框架结构"></a>jQuery框架结构</h2><ol>
<li>为了防止对变量和全局对象的污染，使用沙箱模式</li>
<li>jq的功能是查询DOM和操作DOM，<ul>
<li>在查询时，通过选择器来查询。因此要使用函数去实现Dom元素的查询。在实现时，要先定义一个函数init，</li>
<li>查询到DOM后，要对这些DOM进行操作，此时，要使用面向对象编程的方式来实现，创建一个对象，然后通过该对象的方法来实现操作查询到的DOM元素。</li>
</ul>
</li>
<li>由于框架的结构在完成之后，不允许任何使用者随意改动，所以用户如果想要扩展方法，就必须向其能拿到的对象上扩展，$-&gt;createinit，也就是工厂函数以及其原型。最终要实现init对象继承自createinit函数的原型。</li>
</ol>
<h2 id="jQuery对象的本质"><a href="#jQuery对象的本质" class="headerlink" title="jQuery对象的本质"></a>jQuery对象的本质</h2><pre><code>是一个伪数组对象，在自然数的索引上存储的是查询到的DOM元素，本质是jQuery原型上的init构造函数的实例。
</code></pre><h2 id="init构造函数的参数类型"><a href="#init构造函数的参数类型" class="headerlink" title="init构造函数的参数类型"></a>init构造函数的参数类型</h2><ul>
<li>构造函数中传入参数的类型有很多，所以我们需要对传入的参数进行判断，根据传入参数的不同，实现不同的功能。</li>
</ul>
<ol>
<li><p>string</p>
<ul>
<li>html字符串：创建对应的html元素</li>
<li>选择器：在DOM树上查询元素</li>
</ul>
</li>
<li><p>dom元素</p>
<ul>
<li>将其转换成init对象</li>
</ul>
</li>
</ol>
<ol>
<li><p>dom数组和伪数组</p>
<ul>
<li>转换成init对象</li>
</ul>
</li>
<li><p>函数</p>
<ul>
<li>其实就是入口函数</li>
<li>监听dom树是否加载完毕，如果加载完毕就执行函数</li>
</ul>
</li>
<li><p>非法值 null undefined</p>
</li>
</ol>
<ul>
<li>返回空的init对象</li>
</ul>
<h2 id="添加类型判断方法"><a href="#添加类型判断方法" class="headerlink" title="添加类型判断方法"></a>添加类型判断方法</h2><ul>
<li>根据上面的类型需要做出判断，添加对应的怕段方法</li>
</ul>
<ol>
<li><p>isString方法：判断是否为字符串</p>
</li>
<li><p>isHTML方法：判断是否为html字符串</p>
</li>
<li><p>isDOM方法：判断是否是dom节点</p>
</li>
<li><p>isArrayLike方法：判断是否为数组或伪数组对象</p>
</li>
<li><p>isFunction方法：判断是否为函数类型</p>
</li>
<li><p>isWindow方法：判断是否为window对象</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们通过原生的js实现一些jq的功能，通过练习，锻炼我们的分析问题的能力。锻炼编程的思维能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查询DOM方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;操作DOM方法&lt;ul&gt;
&lt;li&gt;appendTo&lt;/li&gt;
&lt;li&gt;append&lt;
    
    </summary>
    
    
      <category term="js" scheme="https://wangpansheng.github.io/tags/js/"/>
    
      <category term="原生js实现jq，原生框架封装" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0jq%EF%BC%8C%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>JS原型链总结</title>
    <link href="https://wangpansheng.github.io/2016/10/10/js%E5%8E%9F%E5%9E%8B/"/>
    <id>https://wangpansheng.github.io/2016/10/10/js原型/</id>
    <published>2016-10-10T13:22:24.000Z</published>
    <updated>2017-04-24T09:33:12.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="定义：是函数的prototype属性所引用的对象"><a href="#定义：是函数的prototype属性所引用的对象" class="headerlink" title="定义：是函数的prototype属性所引用的对象"></a>定义：是函数的prototype属性所引用的对象</h3><h3 id="目的：为了同类对象之间的数据共享"><a href="#目的：为了同类对象之间的数据共享" class="headerlink" title="目的：为了同类对象之间的数据共享"></a>目的：为了同类对象之间的数据共享</h3><h3 id="实际开发的使用"><a href="#实际开发的使用" class="headerlink" title="实际开发的使用"></a>实际开发的使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 1: 定义构造函数，实现函数体部分</span></div><div class="line"><span class="comment">// 使用构造函数 结合原型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</div><div class="line">	<span class="comment">// 特有的属性写在这里</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 2：将该对象相关的方法定义在原型上</span></div><div class="line"><span class="comment">// 将共有的属性（一般是方法）</span></div><div class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Person.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="comment">// 或者</span></div><div class="line">Person.prototype = &#123;</div><div class="line">	<span class="attr">constructor</span>: Person,</div><div class="line">	<span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">	<span class="attr">run</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 3：创建对象</span></div><div class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="定义：指一个对象有权去访问另一个对象上的成员"><a href="#定义：指一个对象有权去访问另一个对象上的成员" class="headerlink" title="定义：指一个对象有权去访问另一个对象上的成员"></a>定义：指一个对象有权去访问另一个对象上的成员</h3><h3 id="继承的实现"><a href="#继承的实现" class="headerlink" title="继承的实现"></a>继承的实现</h3><ol>
<li><p>原型式</p>
</li>
<li><p>混入式</p>
</li>
<li><p>借用构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"> name, age, sex </span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">	<span class="keyword">this</span>.sex = sex;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, sex, phoneNo </span>) </span>&#123;</div><div class="line">	Animal.call( <span class="keyword">this</span>, name, age, sex );</div><div class="line">	<span class="keyword">this</span>.phoneNo = phoneNo;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Person( <span class="string">'张三'</span>, <span class="number">18</span>, <span class="string">'boy'</span>, <span class="string">'13838383838'</span> );</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="本质是通过-proto-属性连接起来的，体现继承层次关系的。"><a href="#本质是通过-proto-属性连接起来的，体现继承层次关系的。" class="headerlink" title="本质是通过__proto__属性连接起来的，体现继承层次关系的。"></a>本质是通过__proto__属性连接起来的，体现继承层次关系的。</h3><h3 id="掌握程度"><a href="#掌握程度" class="headerlink" title="掌握程度"></a>掌握程度</h3><ol>
<li><p>给定一个对象，可以迅速找到该对象的原型链</p>
</li>
<li><p>找到该对象的三口之家</p>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数是js的一等公民"><a href="#函数是js的一等公民" class="headerlink" title="函数是js的一等公民"></a>函数是js的一等公民</h3><ol>
<li><p>函数有双重身份</p>
<ul>
<li>对象-可以添加属性和方法–静态成员</li>
<li>函数-在调用时，就存在四种调用模式；递归调用</li>
</ul>
</li>
<li><p>可以嵌套使用</p>
<ul>
<li>js使用词法作用域，那么会产生作用域链</li>
</ul>
</li>
<li><p>可以作为其他函数的实参</p>
<ul>
<li>回调函数</li>
</ul>
</li>
<li><p>可以作为其他函数的返回值</p>
<ul>
<li>闭包</li>
</ul>
</li>
<li><p>可以限定作用域</p>
</li>
<li><p>可以作为对象的属性值<br>```</p>
</li>
</ol>
<tag>哈哈哈哈</tag>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h2&gt;&lt;h3 id=&quot;定义：是函数的prototype属性所引用的对象&quot;&gt;&lt;a href=&quot;#定义：是函数的prototype属性所引用的对象&quot; cla
    
    </summary>
    
    
      <category term="JS" scheme="https://wangpansheng.github.io/tags/JS/"/>
    
      <category term="原型" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="原型链" scheme="https://wangpansheng.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
      <category term="函数" scheme="https://wangpansheng.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>canvas入门2</title>
    <link href="https://wangpansheng.github.io/2016/09/11/canvas%E5%85%A5%E9%97%A82/"/>
    <id>https://wangpansheng.github.io/2016/09/11/canvas入门2/</id>
    <published>2016-09-11T00:54:50.000Z</published>
    <updated>2017-04-24T09:33:59.317Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>懒加载：现在不加载，用的时候再加载，</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol>
<li><p>移动的小球 实线思路：</p>
<ul>
<li>简单版</li>
</ul>
<ol>
<li>利用计时器，定时执行</li>
<li>首先绘制一个圆形，圆从左上角出来，然后定时改变圆心的位置，再进行绘制，</li>
<li>等到x轴的坐标大于w或者小于0，改变每一步的正负值，使其反向运动，</li>
</ol>
<ul>
<li>鼠标进入再鼠标所在位置绘制圆形，然后开始下落</li>
</ul>
</li>
<li><p>时钟案例</p>
<ul>
<li>实现效果<br> <img src="/images/clock.png" alt="cloc"></li>
<li>实现思路</li>
</ul>
<ol>
<li>​绘制表盘</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;懒加载：现在不加载，用的时候再加载，&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;案例&quot;&gt;&lt;a href=&quot;#案例&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;&lt;/a&gt;案例&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;移动的小球 实线思路：&lt;/p&gt;
&lt;ul&gt;
&lt;
    
    </summary>
    
    
      <category term="JS" scheme="https://wangpansheng.github.io/tags/JS/"/>
    
      <category term="画布" scheme="https://wangpansheng.github.io/tags/%E7%94%BB%E5%B8%83/"/>
    
      <category term="Canvas" scheme="https://wangpansheng.github.io/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>Canvas入门1</title>
    <link href="https://wangpansheng.github.io/2016/09/10/canvas%E5%85%A5%E9%97%A81/"/>
    <id>https://wangpansheng.github.io/2016/09/10/canvas入门1/</id>
    <published>2016-09-10T13:22:24.000Z</published>
    <updated>2017-04-24T09:34:05.649Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>概念：中文：“画布，帆布”<br>HTML5提出一个新的标签。可以通过脚本语言（JS）在其上面绘制图形、图像以及制作动画。</p>
</li>
<li><p>基本使用</p>
</li>
</ol>
<ul>
<li>创建Canvas标签，同时指定canvas标签的大小；如果不指定的话，默认值为 300 * 150 （px）<br> 如果想动态改变canvas的宽和高，必须通过其属性节点width以及height来改变，不能通过css样式来改变。</li>
<li>通过js获取到canvas对象。本身Canvas不具备绘图能力。</li>
<li>通过Canvas对象调用getContext方法来获取绘图的API方法</li>
<li>使用获取到绘图工具来绘制图形</li>
</ul>
<ol>
<li>getContext方法</li>
</ol>
<ul>
<li>语法: <canvas对象>.getContext(‘2d|WebGL’);</canvas对象></li>
<li>功能：获取绘制平面图形或立体图形的api方法以及相关属性；如果参数值为’2d’<br> ，表示获取绘制平面图形的工具；如果参数值为’WebGL’,表示获取绘制立体图形的工具。</li>
</ul>
<ol>
<li>基本绘图API</li>
</ol>
<ul>
<li>ctx.moveTo(x, y) 移动笔触到指定点。</li>
<li>ctx.lineTo(x, y) 从笔触所在点连线到指定点</li>
<li>ctx.stroke(); 将当前路径绘制的图形描绘其边框</li>
<li>ctx.fill(); 填充一个封闭的图形（将当前路径形成一个封闭图形，然后在填充。）</li>
<li>stroke方法与fill方法可以同时调用</li>
</ul>
<ol>
<li>开启新路径的方法</li>
</ol>
<ul>
<li>ctx.beginPath();</li>
</ul>
<ol>
<li>闭合路径的方法</li>
</ol>
<ul>
<li>ctx.closePath();<br>如果当前路径，没有形成一个封闭的图形，可以调用该方法来将图形闭合。</li>
<li>注意：beginPath与closePath不需要成对出现</li>
</ul>
<ol>
<li><p>非零环绕原则：是用来判断某一封闭的区域是否要填充。<br>如果想判断指定区域是否填充，就在该区域内选择任意点，然后从该点引出一条射线，穿过整个图形到外部。查看该射线与图形的相交线，如果相交线是顺时针穿出射线，计数 + 1；如果是逆时针穿出射线，计数 -1；如果最后所有计数累加在一起，值不为0就填充该区域;</p>
<p>如果相交线是自上而下的穿出射线，即为顺时针穿出，计数 +1<br>如果相交线是自下而上的穿出射线，即为逆时针穿出，计数 -1</p>
</li>
<li><p>奇偶原则：是用来判断某一封闭的区域是否要填充<br>如果想判断指定区域是否填充，就在该区域内选择任意点，然后从该点引出一条射线，穿过整个图形到外部。查看该射线与图形的相交线的个数。如果为奇数，那么就填充；如果为偶数就不填充。</p>
</li>
</ol>
<h3 id="线性相关属性"><a href="#线性相关属性" class="headerlink" title="线性相关属性"></a>线性相关属性</h3><ol>
<li>设置线宽</li>
</ol>
<ul>
<li>ctx.lineWidth = value;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;概念：中文：“画布，帆布”&lt;br&gt;HTML5提出一个新的标签。可以通过脚本语言（JS）在其上面绘制图形、图像以及制作动画。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基本使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;创建Canvas标签，同时指定canv
    
    </summary>
    
    
      <category term="JS" scheme="https://wangpansheng.github.io/tags/JS/"/>
    
      <category term="canvas" scheme="https://wangpansheng.github.io/tags/canvas/"/>
    
      <category term="画布" scheme="https://wangpansheng.github.io/tags/%E7%94%BB%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>关于js中的静态方法和实例方法</title>
    <link href="https://wangpansheng.github.io/2016/08/15/%E5%85%B3%E4%BA%8Ejs%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
    <id>https://wangpansheng.github.io/2016/08/15/关于js中的静态方法和实例方法/</id>
    <published>2016-08-15T14:29:16.000Z</published>
    <updated>2017-04-24T09:36:02.597Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>最近有人问我关于什么静态方法和实例方法不是太清除，所以做一个整理。</p>
</li>
<li><p>什么是静态方法：</p>
<blockquote>
<p>   静态方法是指不需要声明类的实例就可以使用的方法。</p>
</blockquote>
</li>
</ul>
<p>代码演示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="comment">//在foo上直接添加静态方法</span></div><div class="line">foo.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"我是静态方法，不需要实例化，可以直接用函数调用!"</span>);</div><div class="line">&#125;;</div><div class="line">foo.say();<span class="comment">//函数直接调用方法say，打印hello</span></div></pre></td></tr></table></figure></p>
<ul>
<li>什么是实例方法<blockquote>
<p>   实例方法是指必须要先使用”new”关键字声明一个类的实例, 然后才可以通过此实例访问的方法。</p>
</blockquote>
</li>
</ul>
<p>代码演示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"我是实例化之后才可以调用的方法！"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Fn();<span class="comment">//需要首先实例化</span></div><div class="line">obj.say();<span class="comment">//才可以调用</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;最近有人问我关于什么静态方法和实例方法不是太清除，所以做一个整理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么是静态方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   静态方法是指不需要声明类的实例就可以使用的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/
    
    </summary>
    
    
      <category term="函数" scheme="https://wangpansheng.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="js" scheme="https://wangpansheng.github.io/tags/js/"/>
    
      <category term="静态方法" scheme="https://wangpansheng.github.io/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    
      <category term="实例方法" scheme="https://wangpansheng.github.io/tags/%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS系列之模块化介绍</title>
    <link href="https://wangpansheng.github.io/2016/07/20/AngularJS%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wangpansheng.github.io/2016/07/20/AngularJS系列之模块化介绍/</id>
    <published>2016-07-20T05:07:39.000Z</published>
    <updated>2017-04-24T09:29:17.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块化介绍"><a href="#模块化介绍" class="headerlink" title="模块化介绍"></a>模块化介绍</h2><ul>
<li>通过AngularJS构建应用时，是以模块化的方式组织的，即将整个应用划分成若干个模块，每个模块都各有其职责，最终组合成一个整体。</li>
<li>采用模块化的组织方式，可以最大程度的实现代码的复用，可以像搭积木一样进行开发。</li>
</ul>
<h2 id="定义应用"><a href="#定义应用" class="headerlink" title="定义应用"></a>定义应用</h2><ul>
<li><p>通过为任一HTML标签添加ng-app属性，可以指定一个应用，表示此标签所包裹的内容都属于应用的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!--为html标签添加ng-app表明整个文档都是应用--&gt;</div><div class="line">&lt;!--ng-app属性可以不赋值，但是要关联相应模块时则必须赋值--&gt;</div><div class="line">&lt;html lang=&quot;zh-CN&quot; ng-app=&quot;App&quot;&gt;&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h2><ul>
<li><p>AngularJS提供了一个全局对象angular，在此全局对象下存在若干方法，其中angular.module()方法用来定义一个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过module方法定义模块</span></div><div class="line"><span class="comment">//需要传递两个参数，第一个表示模块的名字，</span></div><div class="line"><span class="comment">// 第二个表示此模块依赖的其它模块</span></div><div class="line"><span class="keyword">var</span> app = angular.module(<span class="string">"app"</span>,[]);</div></pre></td></tr></table></figure>
<p>注：应用本质也是一个模块（一个比较大的模块）；</p>
</li>
</ul>
<h2 id="定义控制器"><a href="#定义控制器" class="headerlink" title="定义控制器"></a>定义控制器</h2><ul>
<li><p>控制器（Controller）作为连接模型（model）和视图（view）的桥梁存在，所以当我们定义好了控制器以后，也就定义好了模型和视图。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//app是一个模型实例对象</span></div><div class="line"><span class="comment">//通过这个实例对象定义控制器，需要两个参数</span></div><div class="line"><span class="comment">//第一个参数表示控制器名称，</span></div><div class="line"><span class="comment">//第二个参数是一个数组，这个数组除最后一个单元是函数外，其余都是字符串，标明此控制器的依赖关系</span></div><div class="line">app.controller(<span class="string">'studentController'</span>,[<span class="string">'$scope'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</div><div class="line">  <span class="comment">//模型（model）</span></div><div class="line">  $scope = [</div><div class="line">    &#123;<span class="attr">name</span>: <span class="string">"李白"</span>, <span class="attr">sex</span>: <span class="string">'男'</span>, <span class="attr">age</span>: <span class="string">"23"</span>&#125;,</div><div class="line">    &#123;<span class="attr">name</span>: <span class="string">'华仔'</span>, <span class="attr">sex</span>: <span class="string">'男'</span>, <span class="attr">age</span>: <span class="string">'34'</span>&#125;</div><div class="line">  ]</div><div class="line">&#125;])</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>模型数据时要展示到视图上的，所以需要将控制器关联到视图上，通过为HTML标签添加ng-controller属性并赋值相应的控制器的名称，就确立了关联关系，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--添加ng-controller属性，并赋值为相应的控制器名称--&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">table</span> <span class="attr">ng-controller</span>=<span class="string">"StudentController"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">tr</span> <span class="attr">ng-repeat</span>=<span class="string">"student in students"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;student.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;student.sex&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;student.age&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>以上为AngularJS最基本的MVC工作模式。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模块化介绍&quot;&gt;&lt;a href=&quot;#模块化介绍&quot; class=&quot;headerlink&quot; title=&quot;模块化介绍&quot;&gt;&lt;/a&gt;模块化介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通过AngularJS构建应用时，是以模块化的方式组织的，即将整个应用划分成若干个模块，每个模块都各有其
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AngularJS系列之简单介绍</title>
    <link href="https://wangpansheng.github.io/2016/07/11/AngularJS%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wangpansheng.github.io/2016/07/11/AngularJS介绍/</id>
    <published>2016-07-11T04:45:49.000Z</published>
    <updated>2017-04-24T09:28:54.558Z</updated>
    
    <content type="html"><![CDATA[<p>AngularJS是Google公司开发维护的MVC前端框架；客服了HTMl在构建应用上的不足，降低了开发成本。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>jQuery更准确的说只是一个类库（类库指的是一系列函数的集合）以DOM作为驱动（核心），而AngularJS则是一个框架（诸多类库的集合）以数据和逻辑作为驱动（核心）。</li>
<li>框架对开发流程和模式做了约束，开发者遵照约束进行开发，更注重的实际的业务逻辑。</li>
<li>AngularJS有诸多特性，最为核心的就是：模块化，双向数据绑定，语义化标签，依赖注入等。</li>
<li>类似的框架的还有 BackBone，KnockoutJS，vue，Rect等，</li>
</ul>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ul>
<li>MVC是一种开发模式，有模型（Model），视图（View），控制器（Controller），三部分组成，采用这种开发模式为合理组织代码提供了方便，降低了代码间的耦合度，功能结构清晰可见。</li>
</ul>
<ol>
<li>模型（Model）：一般用来处理数据（读取/设置），具体指操作数据库，</li>
<li>视图（View）：一般用来展示数据，比如通过HTML展示，</li>
<li>控制器（Controller）：一般用作连接模型和属兔的桥梁。</li>
</ol>
<ul>
<li>MVC被引入到前端开发中，由于受到技术的限制，便有了 一些细节的调整，于是出现了MVC的衍生版（子集）如：MVVM，MVW，MVP，MV*等；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AngularJS是Google公司开发维护的MVC前端框架；客服了HTMl在构建应用上的不足，降低了开发成本。&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
    
      <category term="Angular" scheme="https://wangpansheng.github.io/tags/Angular/"/>
    
      <category term="JS" scheme="https://wangpansheng.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
